<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>dp on yaotouge's place</title><link>http://yaotouge.github.io/tags/dp/</link><description>Recent content in dp on yaotouge's place</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 11 Feb 2023 00:00:00 +0000</lastBuildDate><atom:link href="http://yaotouge.github.io/tags/dp/index.xml" rel="self" type="application/rss+xml"/><item><title>LeetCode die simulator</title><link>http://yaotouge.github.io/posts/leetcode/die_simulator/</link><pubDate>Sat, 11 Feb 2023 00:00:00 +0000</pubDate><guid>http://yaotouge.github.io/posts/leetcode/die_simulator/</guid><description>刷题不只是刷题，更重要的是刷各种算法题的思路（套路），找到一个宝藏up主讲的很清楚明了bilibili，茫茫刷题路呀，慢慢来吧。
今天刷每日一题，又碰到一道困难的动态规划题，一下子就懵了，跟着这位up主一起学习。一般的动态规划的步骤是：回溯 =&amp;gt; 记忆化 =&amp;gt; 递推。
回溯就是用深度优先搜索的形式把题解表示出来。 但一般直接dfs肯定会超时，所以会用数组把计算过的结果cache住，递归过程中直接使用。极大优化计算复杂度。 最后dfs是自顶向下的先递后归的过程，我们可以通过自底向上去掉“递”，只留下归的过程，也就是最终的递推关系了。 总结的步骤相当直接明了是不是，但是实际的题目千变万化，唯有勤学苦练才是。今天这道题是模拟掷骰子，老实说，如果不是看了大佬的步骤套路，如果直接一步到位出动态规划的转移方程，我是绝不可能想出来的，甚至最后得到转换的结果后，我依然无法从直观上去理解状态为什么这么转换。只能理解基本的回溯+记忆。
第一步先用回溯表达解题过程，很关键的一点是，虽然题目要求的是最后可能的骰子序列的数量，但我们依然要在模拟掷骰子的基础上来计算总数。所以掷骰子的过程中有两个关键点：
剩余的掷骰子次数，也就是n。 掷出某个点数后是否合法，这个判断依赖两个条件：上一次的点数是多少，以及上个点数的剩余连续次数是多少：如果和上次点数相同，剩余连续次数减一。否则，当前剩余次数重置为 maxRoll - 1。 当n变为0时完成一次序列生成，return 1。然后每次遍历当前可能的点数（1~6）求和得到当前的结果。由此可以写出一个比较清晰的回溯解法：
void dfs(int n, int last, int left, vector&amp;lt;int&amp;gt; &amp;amp;rollMax) { if (n == 0) return 1; int result = 0; for (int i = 0; i &amp;lt; 6; ++i) { if (i != last) result += dfs(n-1, i, rollMax[i]-1); else if (left != 0) result += dfs(n-1, i, left-1); } return result; } int dieRollSimulation(int n, vector&amp;lt;int&amp;gt;&amp;amp; rollMax) { int result = 0; for (int i = 0; i &amp;lt; 6; ++i) { result += dfs(n-1, i, rollMax[i]-1); } return result; } 但是这种写法肯定会超时，所以进行第二步记忆化，将计算过的结果缓存起来，python有个神奇的修饰器 @cache，可以根据函数的输入参数把运算结果缓存，自动完成这步：</description></item><item><title>LeetCode regular expression</title><link>http://yaotouge.github.io/posts/leetcode/regular-expression-leetcode/</link><pubDate>Fri, 10 Feb 2023 00:00:00 +0000</pubDate><guid>http://yaotouge.github.io/posts/leetcode/regular-expression-leetcode/</guid><description>最近打算刷刷题，记录一下做题的思路。现在工作形式不同了，搞技术支持代码写的少，看得多，和人打交道多。。。其实感觉自己不太合适干这个，先凑合着，先刷刷题以后再去别的地儿呢是不是。
动态规划一直没搞明白过，先从这个入手。这是原题链接，估计很多人都刷过了，我自己都做过几遍了。。。但老实说，之前看题解也是一知半解，过不了多久就忘。这次打算理解彻底一点吧。
动态规划的中心是状态转移方程，当前状态根据之前的状态得到，然后用一张表记录之前的结果。这题的思路：
f[i][j] 表示子串s[i]与子pattern p[j]的匹配结果，所以分如下情况：
p[j] == &amp;lsquo;*&amp;rsquo;，此时是0或者多次重复上一个字符，且输入保证*前面必然有字符。这是又分两种情况：
p[j-1] != s[i]，意味着上个pattern字符和s[i]不同，此时只有重复0次有可能匹配成功，那也就看f[i][j-2]的结果。 p[j-1] == s[i]，那我们可以重复0次或者多次，只要其中有一个结果能成功。重复0次就是上面的结果。重复多次这里比较巧妙，看作是消耗掉了一个s[i]，并且依然用p[j]去做后面的匹配，也就是f[i-1][j]，只要它能匹配，那重复多次就能匹配。综合起来，f[i][j]=f[i][j-2] or f[i-1][j]，这里是比较绕的，想了很久。 p[j] == s[i] or p[j] == &amp;lsquo;.&amp;rsquo;，当前字符能匹配，所以匹配结果看f[i-1][j-1]，如果它是true，f[i][j]也是true，否则也是白瞎。
字符不匹配，那么f[i][j]=false;
但即便是理解完这一些系列的状态转换后，写代码时我依然遇到很多阻碍。最麻烦的是边界条件没理解清楚，一开始我是从下标0开始，dp中0表示第一个字符，但这也导致空串并没有被表示，而且dp过程中的数组下标越界的边界情况判断总是不对。后来看了很多解析才恍悟，首先空s或者空p的情况一定要表示出来，此时字符下标从1开始就很方便了，0表示空。
2维数组申请时，维度比s，p的长度+1，这里又引入第二个重点，要把i = 0和j = 0这两边界的元素给计算好，这样dp过程中能直接访问它们的结果。dp[0][0]=true，空串配空串。dp[i][0]这一列都是false（除了0，0处）。dp[0][j]这一行也有点绕，空串和什么样的模式能匹配呢？只有*才行了，所以一切p[j] !=*都false，等于*的还得看dp[0][j-2]是不是匹配成功（是否也为*）。
最后有个地方就是，比如pattern有a*，我们把a和*都单独判断了一次，这样不会有问题是因为我们遇到*后dp会去看j-2的结果，j-1被直接跳过了，也无法影响其他有效结果。明天继续加油，坚持刷题！
class Solution { public: bool isMatch(string s, string p) { // start from 1, 0 stands for empty case char **dp = new char*[s.length() + 1]; for (int i = 0; i &amp;lt; s.length() + 1; ++i) { dp[i] = new char[p.</description></item></channel></rss>