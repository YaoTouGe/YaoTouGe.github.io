---
title: LeetCode well perform interval
date: 2023-02-20
draft: true
tags:
- leetcode
- alg
- two pointer
---

[题目链接](https://leetcode.cn/problems/longest-well-performing-interval/)

断了好几天了，今天继续。这次是一道双指针的题目。同样看了灵神的[视频总结](https://www.bilibili.com/video/BV1hd4y1r7Gq/?spm_id_from=333.788&vd_source=e4ee1e17d171cc432d21d8cdef407806)，双指针有好些类型，以后碰到了一一熟悉，这次的属于同向双指针。

比如求一个正整数数组的连续子序列，使得之和大于n的最短长度，一般做法是两个index表示子序列的左右端点，然后从0开始，右端点往后扫（或者反过来），当满足条件了，右端点停止移动，尝试移动左断点缩小序列长度。当左端点的移动导致条件被破坏，继续移动右端点直到下次条件满足为止。

乍一看直觉上感觉这样做就很对，但是细细一想似乎很多细节又说不上来，还是得自己从头推理深入理解。我们先看如果通过暴力做法，我们会遍历所有可能的右端点，然后每次左端点从0开始往右移动，这样枚举的复杂度是 O(n^2)。如何优化呢？我们从[0,0]开始，首先向右移动`右端点`，找到第一个和大于n的，假设为[0,a]，那么所有以a-1为右端点的子数组之和都小于n，跳过。接着向右移动`左端点`直到和小于n，此时找到a结尾的最短子数组，假设为[b,a]。随后继续右移右端点，由于前面已经找到最短子数组为[b,a]，我们只关心比它更短的子数组，保持左端点不动。当子数组之和再次大于n时，意味着我们有可能搜索到更短的结果，转而开始右移左端点，如此反复。

这个方法能够生效的的前提是条件的单调性，比如我们知道扩大子数组的长度一定会导致和增加，反之一定会减少。

我们回到本题上来，