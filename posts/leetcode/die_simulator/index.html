<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>LeetCode die simulator | yaotouge's place</title><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/fonts.css></head><body><nav><ul class=menu><li><a href=/>Home</a></li><li><a href=/posts/>Posts</a></li><li><a href=/tags/>Tags</a></li><li><a href=/about/>About</a></li></ul><hr></nav><div class=article-meta><h1><span class=title>LeetCode die simulator</span></h1><h2 class=date>2023/02/11</h2></div><main><p>刷题不只是刷题，更重要的是刷各种算法题的思路（套路），找到一个宝藏up主讲的很清楚明了<a href="https://www.bilibili.com/video/BV1Xj411K7oF/?vd_source=e4ee1e17d171cc432d21d8cdef407806">bilibili</a>，茫茫刷题路呀，慢慢来吧。</p><p>今天刷每日一题，又碰到一道困难的动态规划题，一下子就懵了，跟着这位up主一起学习。一般的动态规划的步骤是：回溯 => 记忆化 => 递推。</p><ul><li>回溯就是用深度优先搜索的形式把题解表示出来。</li><li>但一般直接dfs肯定会超时，所以会用数组把计算过的结果cache住，递归过程中直接使用。极大优化计算复杂度。</li><li>最后dfs是自顶向下的先递后归的过程，我们可以通过自底向上去掉“递”，只留下归的过程，也就是最终的递推关系了。</li></ul><p>总结的步骤相当直接明了是不是，但是实际的题目千变万化，唯有勤学苦练才是。今天这道题是<a href=https://leetcode.cn/problems/dice-roll-simulation/>模拟掷骰子</a>，老实说，如果不是看了大佬的步骤套路，如果直接一步到位出动态规划的转移方程，我是绝不可能想出来的，甚至最后得到转换的结果后，我依然无法从直观上去理解状态为什么这么转换。只能理解基本的回溯+记忆。</p><p>第一步先用回溯表达解题过程，很关键的一点是，虽然题目要求的是最后可能的骰子序列的数量，但我们依然要在模拟掷骰子的基础上来计算总数。所以掷骰子的过程中有两个关键点：</p><ol><li>剩余的掷骰子次数，也就是n。</li><li>掷出某个点数后是否合法，这个判断依赖两个条件：上一次的点数是多少，以及上个点数的剩余连续次数是多少：如果和上次点数相同，剩余连续次数减一。否则，当前剩余次数重置为 maxRoll - 1。</li></ol><p>当n变为0时完成一次序列生成，return 1。然后每次遍历当前可能的点数（1~6）求和得到当前的结果。由此可以写出一个比较清晰的回溯解法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>dfs</span>(<span style=color:#66d9ef>int</span> n, <span style=color:#66d9ef>int</span> last, <span style=color:#66d9ef>int</span> left, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>&amp;</span>rollMax)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (n <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> result <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>6</span>; <span style=color:#f92672>++</span>i)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (i <span style=color:#f92672>!=</span> last) result <span style=color:#f92672>+=</span> dfs(n<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, i, rollMax[i]<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (left <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>) result <span style=color:#f92672>+=</span> dfs(n<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, i, left<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> result;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>dieRollSimulation</span>(<span style=color:#66d9ef>int</span> n, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span> rollMax)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> result <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>6</span>; <span style=color:#f92672>++</span>i)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        result <span style=color:#f92672>+=</span> dfs(n<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, i, rollMax[i]<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> result;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>但是这种写法肯定会超时，所以进行第二步记忆化，将计算过的结果缓存起来，python有个神奇的修饰器 @cache，可以根据函数的输入参数把运算结果缓存，自动完成这步：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>dfs</span>(<span style=color:#66d9ef>int</span> n, <span style=color:#66d9ef>int</span> last, <span style=color:#66d9ef>int</span> left, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>&amp;</span>rollMax, <span style=color:#66d9ef>int</span> <span style=color:#f92672>***</span>cache)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (n <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (cache[n][last][left] <span style=color:#f92672>!=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> cache[n][last][left];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> result <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>6</span>; <span style=color:#f92672>++</span>i)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (i <span style=color:#f92672>!=</span> last) result <span style=color:#f92672>+=</span> dfs(n<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, i, rollMax[i]<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (left <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>) result <span style=color:#f92672>+=</span> dfs(n<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, i, left<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    cache[n][last][left] <span style=color:#f92672>=</span> result;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> result;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>下一步就是直接把递归形式转化为迭代的形式，和动态规划的状态转移就能对上号了，有几个要点（这个up主总结的相当到位）：</p><ul><li>回溯的边界为dp的初值。</li><li>把dfs的调用改为dp数组。</li><li>按照dfs的参数嵌套循环。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>dieRollSimulation</span>(<span style=color:#66d9ef>int</span> n, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span> rollMax)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> dp[n][<span style=color:#ae81ff>6</span>][<span style=color:#ae81ff>16</span>];
</span></span><span style=display:flex><span>    <span style=color:#75715e>// init value
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>6</span>; <span style=color:#f92672>++</span>i)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; j <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>16</span>; <span style=color:#f92672>++</span>j)
</span></span><span style=display:flex><span>            dp[<span style=color:#ae81ff>0</span>][i][j] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// recursion are converted to nested for loop
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; j <span style=color:#f92672>&lt;</span> n; <span style=color:#f92672>++</span>j)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> last <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; last <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>6</span>; <span style=color:#f92672>++</span>last)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> left <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; left <span style=color:#f92672>&lt;</span> rollMax[last]; <span style=color:#f92672>++</span>left)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>int</span> result <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>6</span>; <span style=color:#f92672>++</span>i)
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> (i <span style=color:#f92672>!=</span> last) result <span style=color:#f92672>+=</span> dp[j<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>][i][rollMax[i]<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (left <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>) result <span style=color:#f92672>+=</span> dp[j<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>][i][left<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> ret <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>6</span>; <span style=color:#f92672>++</span>i)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        ret <span style=color:#f92672>+=</span> dp[n<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>][i][rollMax[i]<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> ret;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>递归的n=0情况直接用来初始化dp[0][i][j]了，然后dfs的三个参数被展开成三个嵌套循环，一一对应，循环的范围为0~可能的最大值（j从1开始，因为0为边界初值）。到这里其实我还有一个疑问，最内层循环中根据 i 去取 dp[j-1][i][left-1] 或者 dp[j-1][i][rollMax[i]-1] ，这些值一定都已经计算过了吗？答案是肯定的，因为 j-1 是上次最外层循环计算的结果，已经存在于 dp 数组中了。</p><p>最后看大佬题解中还有一步状态优化，能把复杂度从O(nms)降到 O(ns)，暂时还看不懂，等日后熟悉套路了再来。。。</p></main><footer><script type=text/javascript src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></footer></body></html>