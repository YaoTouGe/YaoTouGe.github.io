<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>LeetCode well perform interval | yaotouge's place</title><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/fonts.css></head><body><nav><ul class=menu><li><a href=/>Home</a></li><li><a href=/posts/>Posts</a></li><li><a href=/tags/>Tags</a></li><li><a href=/about/>About</a></li></ul><hr></nav><div class=article-meta><h1><span class=title>LeetCode well perform interval</span></h1><h2 class=date>2023/02/20</h2></div><main><p><a href=https://leetcode.cn/problems/longest-well-performing-interval/>题目链接</a></p><p>断了好几天了，今天继续。这次是一道双指针的题目。同样看了灵神的<a href="https://www.bilibili.com/video/BV1hd4y1r7Gq/?spm_id_from=333.788&vd_source=e4ee1e17d171cc432d21d8cdef407806">视频总结</a>，双指针有好些类型，以后碰到了一一熟悉，这次的属于同向双指针。</p><p>比如求一个正整数数组的连续子序列，使得之和大于n的最短长度，一般做法是两个index表示子序列的左右端点，然后从0开始，右端点往后扫（或者反过来），当满足条件了，右端点停止移动，尝试移动左断点缩小序列长度。当左端点的移动导致条件被破坏，继续移动右端点直到下次条件满足为止。</p><p>乍一看直觉上感觉这样做就很对，但是细细一想似乎很多细节又说不上来，还是得自己从头推理深入理解。我们先看如果通过暴力做法，我们会遍历所有可能的右端点，然后每次左端点从0开始往右移动，这样枚举的复杂度是 O(n^2)。如何优化呢？我们从[0,0]开始，首先向右移动<code>右端点</code>，找到第一个和大于n的，假设为[0,a]，那么所有以a-1为右端点的子数组之和都小于n，跳过。接着向右移动<code>左端点</code>直到和小于n，此时找到a结尾的最短子数组，假设为[b,a]。随后继续右移右端点，由于前面已经找到最短子数组为[b,a]，我们只关心比它更短的子数组，保持左端点不动。当子数组之和再次大于n时，意味着我们有可能搜索到更短的结果，转而开始右移左端点，如此反复。</p><p>这个方法能够生效的的前提是条件的单调性，比如我们知道扩大子数组的长度一定会导致和增加，反之一定会减少。</p><p>我们回到本题上来，</p></main><footer><script type=text/javascript src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></footer></body></html>